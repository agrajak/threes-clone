{"version":3,"sources":["interfaces.ts","models/index.ts","models/matrix.ts","Board.ts","index.ts"],"names":[],"mappings":";AAea,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,KAAA,QAAA,GAAA,QAAA,MAAA,QAAA,UAAA,EAHA,QAAA,KAAO,CAAC,GAAI,GACZ,QAAA,MAAQ,CAAC,EAAG,GACZ,QAAA,GAAK,EAAE,EAAG,GACV,QAAA,KAAO,CAAC,EAAG;;ACWxB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAxBA,IAAA,EAAA,WAAA,SAAA,IACE,KAAA,UAA6B,IAAI,IAqBnC,OApBE,EAAA,UAAA,GAAA,SAAG,EAAc,GACV,KAAA,UAAU,IAAI,CACjB,KAAI,EACJ,QAAO,KAGX,EAAA,UAAA,IAAA,SAAI,GAAJ,IAAA,EAAA,KACE,MAAM,KAAK,KAAK,WACb,OAAO,SAAC,GAAM,OAAA,EAAE,OAAS,IACzB,QAAQ,SAAC,GACR,EAAK,UAAU,OAAO,MAG5B,EAAA,UAAA,KAAA,SAAK,EAAc,QAAA,IAAA,IAAA,OAAA,GACjB,MAAM,KAAK,KAAK,WACb,OAAO,SAAC,GAAM,OAAA,EAAE,OAAS,IACzB,QAAQ,SAAC,GACR,EAAS,QAAQ,MAGzB,EAtBA,GAwBA,QAAA,QAAe;;ACyHd,aAAA,IAAA,EAAA,MAAA,KAAA,WAAA,WAAA,IAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,OAAA,gBAAA,CAAA,UAAA,cAAA,OAAA,SAAA,EAAA,GAAA,EAAA,UAAA,IAAA,SAAA,EAAA,GAAA,IAAA,IAAA,KAAA,EAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,MAAA,EAAA,IAAA,OAAA,SAAA,EAAA,GAAA,SAAA,IAAA,KAAA,YAAA,EAAA,EAAA,EAAA,GAAA,EAAA,UAAA,OAAA,EAAA,OAAA,OAAA,IAAA,EAAA,UAAA,EAAA,UAAA,IAAA,IAAA,GAAA,EAAA,MAAA,KAAA,UAAA,WAAA,OAAA,EAAA,OAAA,QAAA,SAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,UAAA,OAAA,EAAA,EAAA,IAAA,IAAA,IAAA,KAAA,EAAA,UAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,IAAA,MAAA,KAAA,YAAA,EAAA,MAAA,KAAA,gBAAA,WAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,UAAA,OAAA,EAAA,EAAA,IAAA,GAAA,UAAA,GAAA,OAAA,IAAA,EAAA,MAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,IAAA,IAAA,EAAA,UAAA,GAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IAAA,IAAA,EAAA,GAAA,EAAA,GAAA,OAAA,GAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,YAAA,EAnJD,IAAA,EAAA,QAAA,iBACA,EAAA,EAAA,QAAA,YACA,EAAA,SAAA,GAEE,SAAA,IAAA,IAAA,EACE,EAAA,KAAA,OAAO,KA8IV,OA7IG,EAAK,EAAI,MAAM,KAAK,CAAE,OAAQ,IAAM,WAAO,MAAA,CAAE,OAAQ,EAAG,MAAO,KAC/D,EAAK,KAAK,QA4Ib,EAzBD,OAxH4B,EAAA,EAAA,GAO1B,EAAA,UAAA,KAAA,WACO,KAAA,EAAI,MAAM,KAAK,CAAE,OAAQ,IAAM,WAAO,MAAA,CAAE,OAAQ,EAAG,MAAO,KAC1D,IAAA,IAAI,EAAI,EAAG,EAAI,EAAG,IAAK,CACpB,IAAA,EAAQ,IACR,EAAQ,IACT,KAAA,OAAO,EAAO,CAAE,OAAQ,IAE1B,KAAA,KAAK,QAEZ,EAAA,UAAA,IAAA,SAAI,GACE,IAAA,GAAO,EACT,GAAO,EACH,EAAY,GAEd,GADe,GAAa,EAAA,MAAQ,GAAa,EAAA,MACrC,CACV,GAAa,EAAA,KAAM,EAAM,EACpB,GAAa,EAAA,QAAO,EAAM,GAC9B,IAAA,IAAI,EAAM,EAAG,EAAM,EAAG,IACS,GAA9B,KAAK,GAAG,CAAC,EAAK,IAAM,QACtB,EAAU,KAAK,CAAC,EAAK,QAGpB,CACD,GAAa,EAAA,GAAI,EAAM,EAClB,GAAa,EAAA,OAAM,EAAM,GAC7B,IAAA,IAAI,EAAM,EAAG,EAAM,EAAG,IACS,GAA9B,KAAK,GAAG,CAAC,EAAK,IAAM,QACtB,EAAU,KAAK,CAAC,EAAK,IAKvB,OAAoB,GAApB,EAAU,SAGT,KAAA,OAAO,EAAc,GAAY,CAAE,OAAQ,EAAc,CAAC,EAAG,EAAG,MAChE,KAAA,KAAK,QACH,IAET,EAAA,UAAA,MAAA,SAAM,GAAN,IAAA,EAAA,KACS,EAAU,EAAS,GAAf,EAAM,EAAS,GACV,KAAK,uBAAuB,GAEzC,IAAI,SAAC,GAAQ,OAAA,EAAS,KACtB,QAAQ,SAAC,GAAC,IAAA,EAAG,EAAA,GAAE,EAAG,EAAA,GACX,EAAK,EAAM,EACf,EAAK,EAAM,EACP,EAAU,EAAK,GAAG,CAAC,EAAI,IACvB,EAAU,EAAK,GAAG,CAAC,EAAK,IAC9B,EAAK,OAAO,CAAC,EAAI,GAAK,CACpB,OAAQ,EAAQ,OAAS,EAAQ,OACjC,MAAO,EAAQ,MAAQ,EAAQ,QAEjC,EAAK,OAAO,CAAC,EAAK,GAAM,CACtB,OAAQ,EACR,MAAO,MAGR,KAAA,KAAK,UAEZ,EAAA,UAAA,OAAA,SAAO,EAAc,GA8EtB,IAAA,EA7ES,EAAM,EAAM,GACb,KAAA,EAAI,OAAO,OAAO,GAAI,KAAK,IAAC,EAAA,IAC9B,GAAG,EAAA,EAAA,GAAQ,KAAK,GAAG,IAAS,GADtB,KAIX,EAAA,UAAA,GAAA,SAAG,GACK,IAAA,EAAsB,iBAAT,EAAoB,EAAQ,EAAM,GAC9C,OAAA,KAAK,EAAE,IAEhB,EAAA,UAAA,uBAAA,SAAuB,GACjB,IAAC,EAAW,MAAO,GAChB,IAAA,EAAU,EAAS,GAAf,EAAM,EAAS,GACpB,EAAoB,GAEtB,EAAa,GAAa,EAAA,MAAQ,GAAa,EAAA,MAC/C,EAAM,EACR,EAAM,EAEJ,GAAa,EAAA,KAAM,EAAM,EACpB,GAAa,EAAA,MAAO,EAAM,EAC1B,GAAa,EAAA,GAAI,EAAM,EACvB,GAAa,EAAA,OAAM,EAAM,GAE7B,IAAA,IAAI,EAAI,EAAG,EAAI,GAAI,IAAK,CACrB,IAAA,EAAK,EAAK,EACd,EAAK,EAAK,GAET,EAAW,KAAK,GAAG,CAAC,EAAI,IAAK,OAAQ,KAAK,GAAG,CAAC,EAAK,IAAM,UACnB,GAArC,EAAQ,QAAQ,EAAM,CAAC,EAAI,MACC,GAA9B,KAAK,GAAG,CAAC,EAAK,IAAM,QAEpB,EAAQ,KAAK,EAAM,CAAC,EAAK,KAEvB,GACE,EAAI,GAAK,IACX,GAAO,GAET,GAAO,EAAM,GAAK,IAEd,EAAI,GAAK,IACX,GAAO,GAET,GAAO,EAAM,GAAK,GAGf,OAAA,GAET,EAAA,UAAA,QAAA,SAAQ,GACD,KAAA,EAAE,QAAQ,SAAC,EAAM,GACpB,EAAQ,EAAK,EAAS,GAAI,CAAE,EAAK,QAGvC,EAxHA,CAA4B,EAAA,SA0H5B,SAAS,EAAW,EAAW,GACzB,OAAK,GAAL,GAAe,GAAL,IACV,GAAK,GAAK,EAAI,GAAK,GACnB,GAAK,GAAK,EAAI,GAAK,GAAK,EAAI,GAAK,GAGvC,SAAS,EAAa,GACb,YADa,IAAA,IAAA,EAAA,GACb,KAAK,MAAM,KAAK,SAAW,GAEpC,SAAS,IACA,OAAA,EAAa,GAAK,EAE3B,SAAS,IACA,MAAA,CAAC,EAAa,GAAI,EAAa,IAExC,SAAS,EAAS,GACT,MAAA,CAAC,KAAK,MAAM,EAAM,GAAI,EAAM,GAErC,SAAS,EAAM,GACN,OAAM,EADI,EAAA,GAAK,EAAA,GAGxB,SAAS,EAAc,GACd,OAAA,EAAI,KAAK,MAAM,KAAK,SAAW,EAAI,SAhJ/B,QAAA,OAAA;;ACsOZ,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAxOD,IAAA,EAAA,QAAA,mBACA,EAAA,QAAA,gBAEM,EAAW,IACjB,EAAA,WAcE,SAAA,IAZA,KAAA,OAAS,IAAI,EAAA,OACb,KAAA,SAAW,IAAI,MAAY,IAC3B,KAAA,YAAa,EAEb,KAAA,cAAkC,GAClC,KAAA,OAAS,EACT,KAAA,MAAQ,EACR,KAAA,IAAM,EACN,KAAA,EAAI,KACJ,KAAA,EAAI,KACJ,KAAA,UAAW,EAGJ,KAAA,EAAI,SAAS,eAAe,SAC5B,KAAA,eACA,KAAA,SACA,KAAA,YACA,KAAA,OAAO,OAmLhB,OAjLE,EAAA,UAAA,aAAA,WACO,KAAA,OAAO,GAAG,MAAO,KAAK,OAAO,KAAK,OAClC,KAAA,OAAO,GAAG,QAAS,KAAK,OAAO,KAAK,OAEzC,OAAO,iBAAiB,SAAU,KAAK,SAAS,KAAK,OACrD,OAAO,iBAAiB,YAAa,KAAK,UAAU,KAAK,OACzD,OAAO,iBAAiB,UAAW,KAAK,QAAQ,KAAK,OACrD,OAAO,iBAAiB,aAAc,KAAK,QAAQ,KAAK,OACxD,OAAO,iBAAiB,YAAa,KAAK,SAAS,KAAK,OACxD,OAAO,iBAAiB,aAAc,KAAK,UAAU,KAAK,OAC1D,OAAO,iBAAiB,WAAY,KAAK,QAAQ,KAAK,OACtD,OAAO,iBAAiB,YAAa,KAAK,SAAS,KAAK,QAE1D,EAAA,UAAA,SAAA,WACO,KAAA,YACA,KAAA,cACA,KAAA,eAAe,IAEtB,EAAA,UAAA,UAAA,SAAU,GACF,IAAA,EAAuB,KAAK,iBAAiB,GAA3C,EAAO,EAAA,QAAE,EAAO,EAAA,QACnB,KAAA,EAAI,EACJ,KAAA,EAAI,EACJ,KAAA,YAAa,GAEpB,EAAA,UAAA,QAAA,WAAA,IAAA,EAAA,KACM,EAAQ,KAAK,IAAI,KAAK,OAAQ,KAAK,OACnC,EAAQ,KAAK,OAAS,GACnB,KAAA,KAAK,EAAO,KAAK,OAAQ,IAAI,KAAK,WAGjC,GAFJ,EAAK,OAAO,MAAM,EAAK,YACV,EAAK,OAAO,IAAI,EAAK,WAIhC,OAFA,MAAM,cACN,EAAK,OAAO,OAGd,EAAK,YAAa,EAClB,EAAK,UAAY,KACjB,EAAK,MAAQ,IAGV,KAAA,KAAK,EAAO,EAAG,IAAI,KAAK,WAC3B,EAAK,YAAa,EAClB,EAAK,UAAY,KACjB,EAAK,IAAM,QAIjB,EAAA,UAAA,KAAA,SAAK,EAAU,EAAkB,GAAjC,IAAA,EAAA,UAAK,IAAA,IAAA,EAAA,QAAU,IAAA,IAAA,EAAK,KAAK,aAAQ,IAAA,IAAA,EAAA,KACzB,IAAA,EAA4B,GAAjB,KAAK,SACjB,KAAA,UAAW,EACZ,IAAA,EAAU,KACV,EAAiB,KAAK,eAAe,KAAK,MAIvC,OAAA,IAAI,QAAQ,SAAC,EAAS,GACvB,GAAU,IAYd,sBAXa,SAAP,EAAQ,GAER,GADC,IAAS,EAAU,GACpB,EAAY,EAAU,EAIxB,OAHA,IACA,EAAK,UAAW,OAChB,EAAe,GAGjB,EAbK,SAAY,GACX,OAAC,EAAY,GAAW,GAAa,EAAK,GAAQ,EAYzC,CAAY,IAC3B,sBAAsB,QAK5B,EAAA,UAAA,iBAAA,SAAiB,GACX,OAAA,aAAiB,WAAmB,EACjC,EAAM,QAAQ,IAEvB,EAAA,UAAA,SAAA,SAAS,GAAT,IAAA,EAAA,KACM,GAAC,KAAK,WAAN,CACE,IAAA,EAAuB,KAAK,iBAAiB,GAA3C,EAAO,EAAA,QAAE,EAAO,EAAA,QAClB,EAAK,EAAU,KAAK,EACxB,EAAK,EAAU,KAAK,EAClB,GAAM,GAAN,GAAiB,GAAN,EAAX,CACC,KAAA,EAAI,EACJ,KAAA,EAAI,EACH,IAAA,EAAY,EAAyB,EAAI,GAE1C,KAAK,YACH,KAAA,UAAY,EACZ,KAAA,cAAgB,KAAK,OACvB,uBAAuB,GACvB,IAAI,SAAC,GAAQ,OAAA,EAAK,iBAAiB,KAEjC,KAAA,IAAM,KAAK,aAAe,EAAU,GAEvC,IAKE,IALI,KAAK,aAAe,EAAU,GAM/B,KAAK,MACX,KAAK,aAAe,KAAK,UAAU,GAAK,KAAK,UAAU,IAEtD,EAAQ,EACL,KAAA,UAAY,MAId,KAAA,MAAQ,EAER,KAAA,eAAe,KAAK,IAAI,EAAO,KAAK,aAG3C,EAAA,UAAA,eAAA,SAAe,GAAf,IA+FD,EA/FC,EAAA,KACQ,EAAyB,QAAzB,EAAW,KAAK,iBAAS,IAAA,EAAA,EAAI,CAAC,EAAG,GAAhC,EAAE,EAAA,GAAE,EAAE,EAAA,GACP,EAAU,KAAK,OAAO,uBAAuB,KAAK,WACnD,KAAA,OAAO,QAAQ,SAAC,GAAC,IAAA,EAAG,EAAA,GAAE,EAAG,EAAA,GAAE,EAAG,EAAA,GAC7B,GAAe,GADoB,EAAA,GAC9B,OAAL,CACA,IAAA,EAAI,EAAM,EAAK,OACjB,EAAI,EAAM,EAAK,QAEY,GAAzB,EAAQ,QAAQ,KAClB,GAAK,EAAQ,EACb,GAAK,EAAQ,GAET,IAAA,EAAO,EAAK,EAAE,cAClB,cAAc,EAAG,MAEnB,EAAK,MAAM,OAAS,GAAG,EAAK,OAAO,GAAG,GAAK,MAC3C,EAAK,MAAM,UAAY,aAAa,EAAC,OAAO,EAAC,UAIjD,EAAA,UAAA,WAAA,WACS,OAAA,KAAK,WAAa,EAAA,MAAQ,KAAK,WAAa,EAAA,OAGrD,EAAA,UAAA,OAAA,WAAA,IAAA,EAAA,KACO,KAAA,EAAE,iBAAiB,SAAS,QAAQ,SAAC,GACxC,EAAK,EAAE,YAAY,KAEhB,KAAA,OAAO,QAAQ,SAAC,GAAE,EAAA,GAAG,EAAA,GAAJ,IAAM,EAAG,EAAA,GAAE,EAAI,EAAA,GAC/B,GAAe,GAAf,EAAK,OAAL,CACE,IAAA,EAAO,EAAe,GAC5B,EAAe,EAAM,EAAK,QAC1B,EAAK,EAAE,YAAY,MAEhB,KAAA,cACA,KAAA,eAAe,IAGtB,EAAA,UAAA,YAAA,WAAA,IAAA,EAAA,KACO,KAAA,EAAE,iBAAiB,SAAS,QAAQ,SAAC,GAClC,aAAgB,iBACtB,EAAK,MAAM,MAAQ,EAAK,MAAM,OAAY,EAAK,cAAa,SAGhE,EAAA,UAAA,YAAA,WAES,OADU,KAAK,EAAE,cAAc,SACtB,cAGlB,EAAA,UAAA,UAAA,WACM,GAA4B,GAA5B,KAAK,EAAE,WAAW,OAAa,OAAO,EACpC,IAAA,EAAU,SAAS,iBAAiB,KAAK,GAAG,QAC7C,KAAA,OAAS,EAAU,KAAK,eAG/B,EAAA,UAAA,qBAAA,SAAqB,GACb,IAAA,EAAgB,KAAK,EAAE,cAC3B,cAAc,EAAG,MACjB,wBACK,MAAA,CAHI,EAAA,IAAM,EAAA,OAMnB,EAAA,UAAA,iBAAA,SAAiB,GACR,OAAA,KAAK,EAAE,cAAc,cAAc,EAAG,OAEjD,EAtMA,GAwMA,SAAS,EAAyB,EAAW,GACvC,OAAA,KAAK,IAAI,GAAa,KAAK,IAAI,GAC7B,EAAY,EAAU,EAAA,MACd,EAAA,KAER,EAAY,EAAU,EAAA,KACd,EAAA,GAGhB,SAAS,EAAe,EAAsB,GAC5C,EAAK,UAAY,GAAG,EACP,GAAT,EACF,EAAK,UAAU,OAAO,QAEtB,EAAK,UAAU,IAAI,QAErB,EAAK,aAAa,QAAS,EAAQ,IAErC,SAAS,EAAe,GAChB,IAAA,EAAO,SAAS,cAAc,OAK7B,OAJP,EAAK,UAAU,IAAI,aACP,IAAR,GACF,EAAK,aAAa,MAAO,GAEpB,EAET,SAAS,EAAc,EAAO,EAAK,GAC1B,OAAA,KAAK,IAAI,EAAK,KAAK,IAAI,EAAK,IACpC,QAAA,QAAA;;;;ACpOD,aAAA,IAAA,EAAA,MAAA,KAAA,iBAAA,SAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,IAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAJA,IAAA,EAAA,EAAA,QAAA,YACA,QAAA,sBACA,QAAA,sBAGM,IAAA,EAAA","file":"threes-clone.a8fac24e.js","sourceRoot":"..","sourcesContent":["export interface ThreeEvent {\n  type: string;\n  handler: Function;\n}\n\nexport type Point = [number, number];\n\nexport interface Cell {\n  number: number;\n  score: number;\n}\n\nexport const LEFT = [0, -1] as const;\nexport const RIGHT = [0, 1] as const;\nexport const UP = [-1, 0] as const;\nexport const DOWN = [1, 0] as const;\n\nexport type Direction = typeof LEFT | typeof RIGHT | typeof UP | typeof DOWN;\n","import { ThreeEvent } from \"../interfaces\";\n\nclass Model {\n  observers: Set<ThreeEvent> = new Set();\n  on(type: string, handler: Function) {\n    this.observers.add({\n      type,\n      handler,\n    });\n  }\n  off(type: string) {\n    Array.from(this.observers)\n      .filter((x) => x.type === type)\n      .forEach((item: ThreeEvent) => {\n        this.observers.delete(item);\n      });\n  }\n  emit(type: string, payload = undefined) {\n    Array.from(this.observers)\n      .filter((x) => x.type === type)\n      .forEach((observer) => {\n        observer.handler(payload);\n      });\n  }\n}\n\nexport default Model;\n","import { Cell, Direction, DOWN, LEFT, Point, RIGHT, UP } from \"../interfaces\";\nimport Model from \"./index\";\nexport class Matrix extends Model {\n  m: Cell[];\n  constructor() {\n    super();\n    this.m = Array.from({ length: 16 }, () => ({ number: 0, score: 0 }));\n    this.emit(\"init\");\n  }\n  init() {\n    this.m = Array.from({ length: 16 }, () => ({ number: 0, score: 0 }));\n    for (let i = 0; i < 3; i++) {\n      const point = getRandomPoint();\n      const value = getOneOrTwo();\n      this.mutate(point, { number: value });\n    }\n    this.emit(\"add\");\n  }\n  add(direction) {\n    let col = -1,\n      row = -1;\n    const available = [];\n    const isVertical = direction == LEFT || direction == RIGHT;\n    if (isVertical) {\n      if (direction == LEFT) col = 3;\n      else if (direction == RIGHT) col = 0;\n      for (let row = 0; row < 4; row++) {\n        if (this.at([row, col]).number == 0) {\n          available.push([row, col]);\n        }\n      }\n    } else {\n      if (direction == UP) row = 3;\n      else if (direction == DOWN) row = 0;\n      for (let col = 0; col < 4; col++) {\n        if (this.at([row, col]).number == 0) {\n          available.push([row, col]);\n        }\n      }\n    }\n\n    if (available.length == 0) {\n      return false;\n    }\n    this.mutate(pickRandomOne(available), { number: pickRandomOne([1, 2, 3]) });\n    this.emit(\"add\");\n    return true;\n  }\n  merge(direction: Direction) {\n    const [dx, dy] = direction;\n    const indices = this.getMoveableCellIndices(direction);\n    indices\n      .map((idx) => toRowCol(idx))\n      .forEach(([row, col]) => {\n        const _x = row + dx,\n          _y = col + dy;\n        const oldCell = this.at([_x, _y]);\n        const newCell = this.at([row, col]);\n        this.mutate([_x, _y], {\n          number: oldCell.number + newCell.number,\n          score: oldCell.score + newCell.score,\n        });\n        this.mutate([row, col], {\n          number: 0,\n          score: 1,\n        });\n      });\n    this.emit(\"merge\");\n  }\n  mutate(point: Point, value: Partial<Cell>) {\n    const idx = toIdx(point);\n    this.m = Object.assign([], this.m, {\n      [idx]: { ...this.at(idx), ...value },\n    });\n  }\n  at(param: number | Point) {\n    const idx = typeof param == \"number\" ? param : toIdx(param);\n    return this.m[idx];\n  }\n  getMoveableCellIndices(direction: Direction) {\n    if (!direction) return [];\n    const [dx, dy] = direction;\n    const indices: number[] = [];\n\n    let isVertical = direction == LEFT || direction == RIGHT;\n    let row = 0,\n      col = 0;\n\n    if (direction == LEFT) col = 1;\n    else if (direction == RIGHT) col = 2;\n    else if (direction == UP) row = 1;\n    else if (direction == DOWN) row = 2;\n\n    for (let i = 0; i < 12; i++) {\n      const _x = dx + row,\n        _y = dy + col;\n      if (\n        (isMergable(this.at([_x, _y]).number, this.at([row, col]).number) ||\n          indices.indexOf(toIdx([_x, _y])) != -1) &&\n        this.at([row, col]).number != 0\n      ) {\n        indices.push(toIdx([row, col]));\n      }\n      if (isVertical) {\n        if (i % 4 == 3) {\n          col -= dy;\n        }\n        row = (row + 1) % 4;\n      } else {\n        if (i % 4 == 3) {\n          row -= dx;\n        }\n        col = (col + 1) % 4;\n      }\n    }\n    return indices;\n  }\n  iterate(callback) {\n    this.m.forEach((cell, idx) => {\n      callback([...toRowCol(idx), idx, cell]);\n    });\n  }\n}\n\nfunction isMergable(a: number, b: number) {\n  if (a == 0 || b == 0) return true;\n  if (a != b && a + b == 3) return true;\n  if (a == b && a + b != 2 && a + b != 4) return true;\n  return false;\n}\nfunction getRandomInt(max: number = 1) {\n  return Math.floor(Math.random() * max);\n}\nfunction getOneOrTwo() {\n  return getRandomInt(2) + 1;\n}\nfunction getRandomPoint(): Point {\n  return [getRandomInt(4), getRandomInt(4)];\n}\nfunction toRowCol(idx): Point {\n  return [Math.floor(idx / 4), idx % 4];\n}\nfunction toIdx([row, col]: Point) {\n  return row * 4 + col;\n}\nfunction pickRandomOne(arr) {\n  return arr[Math.floor(Math.random() * arr.length)];\n}\n","import { Matrix } from \"./models/matrix\";\r\nimport { Cell, Direction, LEFT, RIGHT, UP, DOWN } from \"./interfaces\";\r\n\r\nconst DURATION = 200;\r\nexport default class Board {\r\n  $: HTMLDivElement;\r\n  matrix = new Matrix();\r\n  snapshot = new Array<Cell>(16);\r\n  isDragging = false;\r\n  direction: Direction;\r\n  moveableCells: HTMLDivElement[] = [];\r\n  maxPos = 0;\r\n  delta = 0;\r\n  pos = 0;\r\n  x = null;\r\n  y = null;\r\n  isMoving = false;\r\n\r\n  constructor() {\r\n    this.$ = document.getElementById(\"board\") as HTMLDivElement;\r\n    this.bindHandlers();\r\n    this.render();\r\n    this.setMaxPos();\r\n    this.matrix.init();\r\n  }\r\n  bindHandlers() {\r\n    this.matrix.on(\"add\", this.render.bind(this));\r\n    this.matrix.on(\"merge\", this.render.bind(this));\r\n\r\n    window.addEventListener(\"resize\", this.onResize.bind(this));\r\n    window.addEventListener(\"mousedown\", this.dragStart.bind(this));\r\n    window.addEventListener(\"mouseup\", this.dragEnd.bind(this));\r\n    window.addEventListener(\"mouseleave\", this.dragEnd.bind(this));\r\n    window.addEventListener(\"mousemove\", this.dragging.bind(this));\r\n    window.addEventListener(\"touchstart\", this.dragStart.bind(this));\r\n    window.addEventListener(\"touchend\", this.dragEnd.bind(this));\r\n    window.addEventListener(\"touchmove\", this.dragging.bind(this));\r\n  }\r\n  onResize() {\r\n    this.setMaxPos();\r\n    this.resizeCards();\r\n    this.translateCells(0);\r\n  }\r\n  dragStart(event) {\r\n    const { clientX, clientY } = this.touchEventHelper(event);\r\n    this.x = clientX;\r\n    this.y = clientY;\r\n    this.isDragging = true;\r\n  }\r\n  dragEnd() {\r\n    let delta = Math.min(this.maxPos, this.delta);\r\n    if (delta / this.maxPos > 0.6) {\r\n      this.move(delta, this.maxPos, 70).then(() => {\r\n        this.matrix.merge(this.direction);\r\n        const done = this.matrix.add(this.direction);\r\n        if (!done) {\r\n          alert(\"님 주금!\");\r\n          this.matrix.init();\r\n          return;\r\n        }\r\n        this.isDragging = false;\r\n        this.direction = null;\r\n        this.delta = 0;\r\n      });\r\n    } else {\r\n      this.move(delta, 0, 70).then(() => {\r\n        this.isDragging = false;\r\n        this.direction = null;\r\n        this.pos = null;\r\n      });\r\n    }\r\n  }\r\n  move(from = 0, to = this.maxPos, duration = 100) {\r\n    const isLocked = this.isMoving == true;\r\n    this.isMoving = true;\r\n    let startAt = null;\r\n    let translateCells = this.translateCells.bind(this);\r\n    function interpolate(timestamp) {\r\n      return ((timestamp - startAt) / duration) * (to - from) + from;\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      if (isLocked) reject();\r\n      const step = (timestamp) => {\r\n        if (!startAt) startAt = timestamp;\r\n        if (timestamp > startAt + duration) {\r\n          resolve();\r\n          this.isMoving = false;\r\n          translateCells(to);\r\n          return;\r\n        }\r\n        translateCells(interpolate(timestamp));\r\n        requestAnimationFrame(step);\r\n      };\r\n      requestAnimationFrame(step);\r\n    });\r\n  }\r\n  touchEventHelper(event: MouseEvent | TouchEvent) {\r\n    if (event instanceof MouseEvent) return event;\r\n    return event.touches[0];\r\n  }\r\n  dragging(event) {\r\n    if (!this.isDragging) return;\r\n    const { clientX, clientY } = this.touchEventHelper(event);\r\n    const dx = clientX - this.x,\r\n      dy = clientY - this.y;\r\n    if (dx == 0 && dy == 0) return;\r\n    this.x = clientX;\r\n    this.y = clientY;\r\n    const direction = getDirectionFromMovement(dx, dy);\r\n\r\n    if (!this.direction) {\r\n      this.direction = direction;\r\n      this.moveableCells = this.matrix\r\n        .getMoveableCellIndices(direction)\r\n        .map((idx) => this.getCardNodeByIdx(idx));\r\n\r\n      this.pos = this.isVertical() ? clientX : clientY;\r\n    }\r\n    let pos = this.isVertical() ? clientX : clientY;\r\n\r\n    /**\r\n     * delta: 방향에 따른 상대 거리. 내가 맨처음에 의도한 방향으로 움직이고 있으면 부호가 +, 반대 방향으로 움직이고 있으면 -\r\n     */\r\n    const delta =\r\n      (pos - this.pos) *\r\n      (this.isVertical() ? this.direction[1] : this.direction[0]);\r\n\r\n    if (delta < 0) {\r\n      this.direction = null;\r\n      return;\r\n    }\r\n\r\n    this.delta = delta;\r\n\r\n    this.translateCells(Math.min(delta, this.maxPos));\r\n  }\r\n\r\n  translateCells(delta) {\r\n    const [dx, dy] = this.direction ?? [0, 0];\r\n    const indices = this.matrix.getMoveableCellIndices(this.direction);\r\n    this.matrix.iterate(([row, col, idx, cell]) => {\r\n      if (cell.number == 0) return;\r\n      let y = row * this.maxPos,\r\n        x = col * this.maxPos;\r\n\r\n      if (indices.indexOf(idx) != -1) {\r\n        y += delta * dx;\r\n        x += delta * dy;\r\n      }\r\n      const node = this.$.querySelector(\r\n        `.card[idx=\"${idx}\"]`\r\n      ) as HTMLDivElement;\r\n      node.style.zIndex = `${this.matrix.at(idx).score}`;\r\n      node.style.transform = `translate(${x}px, ${y}px)`;\r\n    });\r\n  }\r\n\r\n  isVertical() {\r\n    return this.direction == LEFT || this.direction == RIGHT;\r\n  }\r\n\r\n  render() {\r\n    this.$.querySelectorAll(\".card\").forEach((node) => {\r\n      this.$.removeChild(node);\r\n    });\r\n    this.matrix.iterate(([_, _, idx, cell]) => {\r\n      if (cell.number == 0) return;\r\n      const node = createCardNode(idx);\r\n      changeCardNode(node, cell.number);\r\n      this.$.appendChild(node);\r\n    });\r\n    this.resizeCards();\r\n    this.translateCells(0);\r\n  }\r\n\r\n  resizeCards() {\r\n    this.$.querySelectorAll(\".card\").forEach((node) => {\r\n      if (!(node instanceof HTMLDivElement)) return;\r\n      node.style.width = node.style.height = `${this.getCardSize()}px`;\r\n    });\r\n  }\r\n  getCardSize() {\r\n    const cellNode = this.$.querySelector(\".cell\") as HTMLDivElement;\r\n    return cellNode.offsetHeight;\r\n  }\r\n\r\n  setMaxPos() {\r\n    if (this.$.childNodes.length == 0) return 0;\r\n    const gapSize = parseInt(getComputedStyle(this.$).rowGap);\r\n    this.maxPos = gapSize + this.getCardSize();\r\n  }\r\n\r\n  getCardPositionByIdx(idx: number) {\r\n    const { top, left } = this.$.querySelector(\r\n      `.cell[idx=\"${idx}\"]`\r\n    ).getBoundingClientRect();\r\n    return [top, left];\r\n  }\r\n\r\n  getCardNodeByIdx(idx: number) {\r\n    return this.$.querySelector(`.card[idx=\"${idx}\"]`) as HTMLDivElement;\r\n  }\r\n}\r\n\r\nfunction getDirectionFromMovement(movementX, movementY) {\r\n  if (Math.abs(movementX) > Math.abs(movementY)) {\r\n    if (movementX > 0) return RIGHT;\r\n    else return LEFT;\r\n  } else {\r\n    if (movementY > 0) return DOWN;\r\n    else return UP;\r\n  }\r\n}\r\nfunction changeCardNode(node: HTMLDivElement, value: number) {\r\n  node.innerText = `${value}`;\r\n  if (value == 0) {\r\n    node.classList.remove(\"card\");\r\n  } else {\r\n    node.classList.add(\"card\");\r\n  }\r\n  node.setAttribute(\"value\", value + \"\");\r\n}\r\nfunction createCardNode(idx) {\r\n  const node = document.createElement(\"div\");\r\n  node.classList.add(\"card\");\r\n  if (idx !== undefined) {\r\n    node.setAttribute(\"idx\", idx);\r\n  }\r\n  return node;\r\n}\r\nfunction betweenMinMax(value, min, max) {\r\n  return Math.min(max, Math.max(min, value));\r\n}\r\n","import Board from \"./Board\";\r\nimport \"./styles/index.css\";\r\nimport \"./styles/cards.css\";\r\n\r\n(function () {\r\n  new Board();\r\n})();\r\n"]}